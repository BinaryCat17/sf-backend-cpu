#include <sionflow/ops/sf_ops_core.h>
#include "sf_kernel_utils.h"
#include <sionflow/isa/sf_opcodes.h>
#include <sionflow/base/sf_math.h>
#include <sionflow/isa/sf_exec_ctx.h>
#include "sf_ops_internal.h"
#include <math.h>

/**
 * SionFlow CPU Kernels (Auto-generated)
 * Automatically generated from isa.json and cpu_spec.json. DO NOT EDIT.
 */

{% for node_id, impl in implementations.items() %}
{% set node = nodes_by_id[node_id] %}
{% if node and impl.expression %}
void op_{{ node.opcode }}(sf_exec_ctx* ctx, const struct sf_instruction* inst) {
    const size_t sz = ctx->batch_size;
    u8* d_ptr = (u8*)ctx->reg_ptrs[inst->dest_idx];
    u8* a_ptr = (u8*)ctx->reg_ptrs[inst->src1_idx];
    {% if node.inputs|length >= 2 %}u8* b_ptr = (u8*)ctx->reg_ptrs[inst->src2_idx];{% endif %}
    {% if node.inputs|length >= 3 %}u8* c_ptr = (u8*)ctx->reg_ptrs[inst->src3_idx];{% endif %}
    {% if node.inputs|length >= 4 %}u8* d_in_ptr = (u8*)ctx->reg_ptrs[inst->src4_idx];{% endif %}
    
    const i32 st0 = ctx->reg_strides[inst->dest_idx][ctx->ndim-1];
    const i32 st1 = ctx->reg_strides[inst->src1_idx][ctx->ndim-1];
    {% if node.inputs|length >= 2 %}const i32 st2 = ctx->reg_strides[inst->src2_idx][ctx->ndim-1];{% endif %}
    {% if node.inputs|length >= 3 %}const i32 st3 = ctx->reg_strides[inst->src3_idx][ctx->ndim-1];{% endif %}
    {% if node.inputs|length >= 4 %}const i32 st4 = ctx->reg_strides[inst->src4_idx][ctx->ndim-1];{% endif %}
    
    // Fast Path: All strides are standard (sizeof(f32))
    if (st0 == 4 && st1 == 4 {% if node.inputs|length >= 2 %}&& st2 == 4{% endif %} {% if node.inputs|length >= 3 %}&& st3 == 4{% endif %} {% if node.inputs|length >= 4 %}&& st4 == 4{% endif %}) {
        f32* d = (f32*)d_ptr;
        f32* a = (f32*)a_ptr;
        {% if node.inputs|length >= 2 %}f32* b = (f32*)b_ptr;{% endif %}
        {% if node.inputs|length >= 3 %}f32* c = (f32*)c_ptr;{% endif %}
        {% if node.inputs|length >= 4 %}f32* din = (f32*)d_in_ptr;{% endif %}
        for(size_t i=0; i<sz; ++i) {
            const f32 va = a[i];
            {% if node.inputs|length >= 2 %}const f32 vb = b[i];{% endif %}
            {% if node.inputs|length >= 3 %}const f32 vc = c[i];{% endif %}
            {% if node.inputs|length >= 4 %}const f32 vd = din[i];{% endif %}
            const f32 result = (f32)({{ impl.expression }});
            d[i] = isfinite(result) ? result : 0.0f;
        }
        return;
    }

    for(size_t i=0; i<sz; ++i) {
        const f32 va = *(f32*)a_ptr;
        {% if node.inputs|length >= 2 %}const f32 vb = *(f32*)b_ptr;{% endif %}
        {% if node.inputs|length >= 3 %}const f32 vc = *(f32*)c_ptr;{% endif %}
        {% if node.inputs|length >= 4 %}const f32 vd = *(f32*)d_in_ptr;{% endif %}
        
        const f32 result = (f32)({{ impl.expression }});
        *(f32*)d_ptr = isfinite(result) ? result : 0.0f;
        
        a_ptr += st1;
        {% if node.inputs|length >= 2 %}b_ptr += st2;{% endif %}
        {% if node.inputs|length >= 3 %}c_ptr += st3;{% endif %}
        {% if node.inputs|length >= 4 %}d_in_ptr += st4;{% endif %}
        d_ptr += st0;
    }
}
{% endif %}
{% endfor %}
