#include <sionflow/ops/sf_ops_core.h>
#include "sf_kernel_utils.h"
#include <sionflow/isa/sf_opcodes.h>
#include <sionflow/base/sf_math.h>
#include <sionflow/isa/sf_exec_ctx.h>
#include "sf_ops_internal.h"
#include <math.h>

{% import "sf_macros.c.j2" as dsl %}

/**
 * SionFlow CPU Kernels (Auto-generated)
 * Automatically generated from isa.json and cpu_spec.json. DO NOT EDIT.
 */

{% for node_id, impl in implementations.items() %}
{% set node = nodes_by_id[node_id] %}
{% if node and (impl.expression or impl.template) %}
void op_{{ node.opcode }}(sf_exec_ctx* ctx, const struct sf_instruction* inst) {
    const size_t sz = ctx->batch_size;
    u8* d_ptr = (u8*)ctx->reg_ptrs[inst->dest_idx];
    u8* a_ptr = (u8*)ctx->reg_ptrs[inst->src1_idx];
    {% if node.inputs|length >= 2 %}u8* b_ptr = (u8*)ctx->reg_ptrs[inst->src2_idx];{% endif %}
    {% if node.inputs|length >= 3 %}u8* c_ptr = (u8*)ctx->reg_ptrs[inst->src3_idx];{% endif %}
    {% if node.inputs|length >= 4 %}u8* d_in_ptr = (u8*)ctx->reg_ptrs[inst->src4_idx];{% endif %}
    
    const int last_dim = (ctx->ndim > 0) ? (int)ctx->ndim - 1 : 0;
    const i32 st0 = ctx->reg_strides[inst->dest_idx][last_dim];
    const i32 st1 = ctx->reg_strides[inst->src1_idx][last_dim];
    {% if node.inputs|length >= 2 %}const i32 st2 = ctx->reg_strides[inst->src2_idx][last_dim];{% endif %}
    {% if node.inputs|length >= 3 %}const i32 st3 = ctx->reg_strides[inst->src3_idx][last_dim];{% endif %}
    {% if node.inputs|length >= 4 %}const i32 st4 = ctx->reg_strides[inst->src4_idx][last_dim];{% endif %}

    // Dimension Helpers
    const int32_t s1_last_dim = (ctx->reg_info[inst->src1_idx].ndim > 0) ? ctx->reg_info[inst->src1_idx].shape[ctx->reg_info[inst->src1_idx].ndim - 1] : 1;
    (void)s1_last_dim;

    {% if impl.template %}
        {% if 'sf_dot' in impl.template %}
            {% set expr = dsl.sf_dot('va', 'vb', 's1_last_dim') %}
        {% elif 'sf_length' in impl.template %}
            {% set expr = dsl.sf_length('va', 's1_last_dim') %}
        {% elif 'sf_normalize' in impl.template %}
            {% set expr = dsl.sf_normalize('va', 's1_last_dim') %}
        {% else %}
            {% set expr = impl.template %}
        {% endif %}
    {% else %}
        {% set expr = impl.expression %}
    {% endif %}

    // Fast Path: All strides are standard (sizeof(f32))
    if (st0 == 4 && st1 == 4 {% if node.inputs|length >= 2 %}&& st2 == 4{% endif %} {% if node.inputs|length >= 3 %}&& st3 == 4{% endif %} {% if node.inputs|length >= 4 %}&& st4 == 4{% endif %}) {
        f32* d = (f32*)d_ptr;
        f32* a = (f32*)a_ptr;
        {% if node.inputs|length >= 2 %}f32* b = (f32*)b_ptr;{% endif %}
        {% if node.inputs|length >= 3 %}f32* c = (f32*)c_ptr;{% endif %}
        {% if node.inputs|length >= 4 %}f32* din = (f32*)d_in_ptr;{% endif %}
        for(size_t i=0; i<sz; ++i) {
            const f32 va = a[i];
            {% if node.inputs|length >= 2 %}const f32 vb = b[i];{% endif %}
            {% if node.inputs|length >= 3 %}const f32 vc = c[i];{% endif %}
            {% if node.inputs|length >= 4 %}const f32 vd = din[i];{% endif %}
            
            // Pointers for DSL macros
            const void* va_ptr = &a[i];
            {% if node.inputs|length >= 2 %}const void* vb_ptr = &b[i];{% endif %}
            {% if node.inputs|length >= 3 %}const void* vc_ptr = &c[i];{% endif %}
            {% if node.inputs|length >= 4 %}const void* vd_ptr = &din[i];{% endif %}
            (void)va_ptr; {% if node.inputs|length >= 2 %}(void)vb_ptr;{% endif %} {% if node.inputs|length >= 3 %}(void)vc_ptr;{% endif %} {% if node.inputs|length >= 4 %}(void)vd_ptr;{% endif %}

            const f32 result = (f32)({{ expr }});
            d[i] = isfinite(result) ? result : 0.0f;
        }
        return;
    }

    for(size_t i=0; i<sz; ++i) {
        const f32 va = *(f32*)a_ptr;
        {% if node.inputs|length >= 2 %}const f32 vb = *(f32*)b_ptr;{% endif %}
        {% if node.inputs|length >= 3 %}const f32 vc = *(f32*)c_ptr;{% endif %}
        {% if node.inputs|length >= 4 %}const f32 vd = *(f32*)d_in_ptr;{% endif %}
        
        // Pointers for DSL macros
        const void* va_ptr = a_ptr;
        {% if node.inputs|length >= 2 %}const void* vb_ptr = b_ptr;{% endif %}
        {% if node.inputs|length >= 3 %}const void* vc_ptr = c_ptr;{% endif %}
        {% if node.inputs|length >= 4 %}const void* vd_ptr = d_in_ptr;{% endif %}
        (void)va_ptr; {% if node.inputs|length >= 2 %}(void)vb_ptr;{% endif %} {% if node.inputs|length >= 3 %}(void)vc_ptr;{% endif %} {% if node.inputs|length >= 4 %}(void)vd_ptr;{% endif %}

        const f32 result = (f32)({{ expr }});
        *(f32*)d_ptr = isfinite(result) ? result : 0.0f;
        
        a_ptr += st1;
        {% if node.inputs|length >= 2 %}b_ptr += st2;{% endif %}
        {% if node.inputs|length >= 3 %}c_ptr += st3;{% endif %}
        {% if node.inputs|length >= 4 %}d_in_ptr += st4;{% endif %}
        d_ptr += st0;
    }
}
{% endif %}
{% endfor %}
